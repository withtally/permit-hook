// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import {Test, console} from "forge-std/Test.sol";
import {Permitter} from "../../src/Permitter.sol";
import {IPermitter} from "../../src/interfaces/IPermitter.sol";

/// @title Security Audit - Exploit Proof of Concepts
/// @notice Demonstrates critical vulnerabilities found during security audit
/// @dev Run with: forge test --match-contract ExploitTests -vvvv
contract ExploitTests is Test {
    Permitter public target;

    address public owner = makeAddr("owner");
    address public trustedSigner;
    uint256 public signerPrivateKey;
    address public bidder = makeAddr("bidder");

    uint256 public constant INITIAL_MAX_TOTAL_ETH = 100 ether;
    uint256 public constant INITIAL_MAX_TOKENS_PER_BIDDER = 1000 ether;

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256("Permit(address bidder,uint256 maxBidAmount,uint256 expiry)");

    function setUp() public {
        signerPrivateKey = 0x1234;
        trustedSigner = vm.addr(signerPrivateKey);

        target = new Permitter(
            trustedSigner,
            INITIAL_MAX_TOTAL_ETH,
            INITIAL_MAX_TOKENS_PER_BIDDER,
            owner
        );

        vm.label(address(target), "Permitter");
        vm.label(owner, "Owner");
        vm.label(bidder, "Bidder");
    }

    function _createPermitSignature(address _bidder, uint256 _maxBidAmount, uint256 _expiry)
        internal
        view
        returns (bytes memory permitData)
    {
        IPermitter.Permit memory permit = IPermitter.Permit({
            bidder: _bidder,
            maxBidAmount: _maxBidAmount,
            expiry: _expiry
        });

        bytes32 structHash = keccak256(
            abi.encode(PERMIT_TYPEHASH, permit.bidder, permit.maxBidAmount, permit.expiry)
        );

        bytes32 domainSeparator = target.domainSeparator();
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        permitData = abi.encode(permit, signature);
    }

    /// ============================================================
    /// EXPLOIT 1: Owner DoS via Zero Caps (CRITICAL)
    /// ============================================================
    /// @notice Owner can set caps to zero, DoS-ing the entire auction
    /// @dev No validation prevents setting maxTotalEth or maxTokensPerBidder to 0
    function testExploit_OwnerDoSViaZeroCaps() public {
        console.log("\n=== EXPLOIT 1: Owner DoS via Zero Caps ===");
        console.log("Severity: CRITICAL");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        // Verify bids work initially
        target.validateBid(bidder, 100 ether, 10 ether, permitData);
        console.log("Initial bid succeeded. totalEthRaised:", target.getTotalEthRaised());

        // ATTACK: Owner sets cap to zero
        console.log("\nOwner sets maxTotalEth to 0...");
        vm.prank(owner);
        target.updateMaxTotalEth(0);

        // All future bids now fail
        vm.expectRevert(
            abi.encodeWithSelector(
                IPermitter.ExceedsTotalCap.selector,
                1 ether,  // requested
                0,        // cap (now zero)
                10 ether  // already raised
            )
        );
        target.validateBid(bidder, 50 ether, 1 ether, permitData);

        console.log("All bids now BLOCKED - auction DoS'd!");
        console.log("\nIMPACT: Malicious or compromised owner can halt auction completely");
    }

    /// ============================================================
    /// EXPLOIT 2: State Invariant Violation via Cap Reduction (HIGH)
    /// ============================================================
    /// @notice Owner can reduce caps below already-raised amounts
    /// @dev Creates invalid state where totalEthRaised > maxTotalEth
    function testExploit_StateInvariantViolation() public {
        console.log("\n=== EXPLOIT 2: State Invariant Violation ===");
        console.log("Severity: HIGH");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        // Raise 50 ETH
        target.validateBid(bidder, 500 ether, 50 ether, permitData);
        console.log("ETH raised:", target.getTotalEthRaised());
        console.log("maxTotalEth:", target.maxTotalEth());

        // ATTACK: Owner sets cap BELOW already raised amount
        console.log("\nOwner reduces maxTotalEth to 30 ether (below 50 already raised)...");
        vm.prank(owner);
        target.updateMaxTotalEth(30 ether);

        // State invariant is now violated!
        assertTrue(
            target.getTotalEthRaised() > target.maxTotalEth(),
            "Invariant should be violated"
        );

        console.log("STATE CORRUPTED:");
        console.log("  totalEthRaised:", target.getTotalEthRaised());
        console.log("  maxTotalEth:", target.maxTotalEth());
        console.log("\nIMPACT: Core invariant (totalEthRaised <= maxTotalEth) violated!");
    }

    /// ============================================================
    /// EXPLOIT 3: TOCTOU Front-Running Attack (HIGH)
    /// ============================================================
    /// @notice Owner can front-run pending bids by changing caps
    /// @dev Race condition between cap check and state update
    function testExploit_TOCTOUFrontRun() public {
        console.log("\n=== EXPLOIT 3: TOCTOU Front-Running ===");
        console.log("Severity: HIGH");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        // First bid succeeds
        target.validateBid(bidder, 200 ether, 20 ether, permitData);
        console.log("First bid succeeded. Bidder cumulative:", target.getBidAmount(bidder));

        // Simulate: Owner sees pending 250 ether bid in mempool
        // Owner front-runs by lowering maxTokensPerBidder
        console.log("\nOwner sees pending 250 ether bid in mempool...");
        console.log("Owner front-runs by lowering maxTokensPerBidder to 300 ether");

        vm.prank(owner);
        target.updateMaxTokensPerBidder(300 ether);

        // Bidder's transaction now fails (200 + 250 = 450 > 300)
        vm.expectRevert(
            abi.encodeWithSelector(
                IPermitter.ExceedsPersonalCap.selector,
                250 ether,  // requested
                300 ether,  // cap
                200 ether   // already bid
            )
        );
        target.validateBid(bidder, 250 ether, 25 ether, permitData);

        console.log("Bidder's pending transaction REVERTED due to front-run!");
        console.log("\nIMPACT: Owner can selectively censor bids via cap manipulation");
    }

    /// ============================================================
    /// EXPLOIT 4: Signer Rotation Invalidates All Permits (MEDIUM)
    /// ============================================================
    /// @notice Updating trustedSigner instantly invalidates all existing permits
    /// @dev No grace period for transition
    function testExploit_SignerRotationInvalidatesPermits() public {
        console.log("\n=== EXPLOIT 4: Signer Rotation Invalidates All Permits ===");
        console.log("Severity: MEDIUM");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        console.log("Bidder has valid permit signed by:", trustedSigner);

        // Owner rotates signer (could be emergency key rotation)
        uint256 newSignerKey = 0x5678;
        address newSigner = vm.addr(newSignerKey);

        console.log("Owner rotates to new signer:", newSigner);
        vm.prank(owner);
        target.updateTrustedSigner(newSigner);

        // ALL existing permits are now invalid
        vm.expectRevert(
            abi.encodeWithSelector(
                IPermitter.InvalidSignature.selector,
                newSigner,      // expected (new)
                trustedSigner   // recovered (old)
            )
        );
        target.validateBid(bidder, 100 ether, 10 ether, permitData);

        console.log("Bidder's valid permit is now INVALID!");
        console.log("\nIMPACT: All users with pending permits locked out after signer rotation");
    }

    /// ============================================================
    /// EXPLOIT 5: No Caller Validation on validateBid (MEDIUM)
    /// ============================================================
    /// @notice Anyone can call validateBid, not just CCA contract
    /// @dev Allows pre-filling cumulative bids if caller can control parameters
    function testExploit_NoCallerValidation() public {
        console.log("\n=== EXPLOIT 5: No Caller Validation ===");
        console.log("Severity: MEDIUM");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        address attacker = makeAddr("attacker");
        console.log("Attacker (not CCA contract):", attacker);

        // Attacker directly calls validateBid
        vm.prank(attacker);
        target.validateBid(bidder, 100 ether, 10 ether, permitData);

        console.log("Attacker successfully called validateBid!");
        console.log("Bidder's cumulative bids increased to:", target.getBidAmount(bidder));

        console.log("\nIMPACT: If attacker has permit data, can manipulate bid state");
        console.log("Trust assumption: Only CCA should call this function");
    }

    /// ============================================================
    /// EXPLOIT 6: Constructor Accepts Zero Caps (LOW)
    /// ============================================================
    /// @notice Permitter can be deployed with zero caps
    /// @dev Results in unusable contract
    function testExploit_ConstructorZeroCaps() public {
        console.log("\n=== EXPLOIT 6: Constructor Accepts Zero Caps ===");
        console.log("Severity: LOW");

        // Deploy with zero caps - succeeds!
        Permitter brokenPermitter = new Permitter(
            trustedSigner,
            0,  // maxTotalEth = 0
            0,  // maxTokensPerBidder = 0
            owner
        );

        console.log("Deployed Permitter with zero caps!");
        console.log("  maxTotalEth:", brokenPermitter.maxTotalEth());
        console.log("  maxTokensPerBidder:", brokenPermitter.maxTokensPerBidder());

        // All bids will fail
        uint256 expiry = block.timestamp + 1 hours;

        IPermitter.Permit memory permit = IPermitter.Permit({
            bidder: bidder,
            maxBidAmount: 100 ether,
            expiry: expiry
        });

        bytes32 structHash = keccak256(
            abi.encode(PERMIT_TYPEHASH, permit.bidder, permit.maxBidAmount, permit.expiry)
        );
        bytes32 domainSeparator = brokenPermitter.domainSeparator();
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);
        bytes memory permitData = abi.encode(permit, signature);

        // Even 1 wei bid fails
        vm.expectRevert(
            abi.encodeWithSelector(
                IPermitter.ExceedsPersonalCap.selector,
                1,  // requested
                0,  // cap
                0   // already bid
            )
        );
        brokenPermitter.validateBid(bidder, 1, 1, permitData);

        console.log("Contract is completely unusable!");
        console.log("\nIMPACT: Misconfigured deployment results in dead contract");
    }

    /// ============================================================
    /// EXPLOIT 7: No Ownership Transfer (MEDIUM)
    /// ============================================================
    /// @notice Owner cannot be changed after deployment
    /// @dev If owner key is lost/compromised, no recovery possible
    function testExploit_NoOwnershipTransfer() public {
        console.log("\n=== EXPLOIT 7: No Ownership Transfer ===");
        console.log("Severity: MEDIUM");

        address currentOwner = target.owner();
        console.log("Current owner:", currentOwner);

        // There is no transferOwnership function!
        // Try all possible function selectors for ownership transfer
        bytes4 transferSelector = bytes4(keccak256("transferOwnership(address)"));
        bytes4 setOwnerSelector = bytes4(keccak256("setOwner(address)"));

        console.log("Checking for transferOwnership function...");
        (bool success,) = address(target).staticcall(
            abi.encodeWithSelector(transferSelector, makeAddr("newOwner"))
        );
        console.log("  transferOwnership exists:", success);

        console.log("Checking for setOwner function...");
        (success,) = address(target).staticcall(
            abi.encodeWithSelector(setOwnerSelector, makeAddr("newOwner"))
        );
        console.log("  setOwner exists:", success);

        console.log("\nNo ownership transfer mechanism found!");
        console.log("\nIMPACT: Owner address is immutable - key loss = permanent lockout");
    }

    /// ============================================================
    /// EXPLOIT 8: Unbounded Pause (MEDIUM)
    /// ============================================================
    /// @notice Owner can pause indefinitely with no auto-unpause
    /// @dev No timelock or governance override
    function testExploit_UnboundedPause() public {
        console.log("\n=== EXPLOIT 8: Unbounded Pause ===");
        console.log("Severity: MEDIUM");

        uint256 expiry = block.timestamp + 1 hours;
        bytes memory permitData = _createPermitSignature(bidder, 500 ether, expiry);

        // Owner pauses
        vm.prank(owner);
        target.pause();
        console.log("Contract paused at block:", block.number);

        // Fast forward 1 year
        vm.warp(block.timestamp + 365 days);
        console.log("Time advanced 1 year...");

        // Still paused!
        assertTrue(target.paused(), "Should still be paused");

        vm.expectRevert(IPermitter.ContractPaused.selector);
        target.validateBid(bidder, 100 ether, 10 ether, permitData);

        console.log("Contract still paused after 1 year!");
        console.log("\nIMPACT: No automatic unpause or governance override");
        console.log("If owner key lost while paused, contract locked forever");
    }
}
