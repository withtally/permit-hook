// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import {Test, console} from "forge-std/Test.sol";
import {Permitter} from "../src/Permitter.sol";
import {IPermitter} from "../src/interfaces/IPermitter.sol";

/// @title Security Audit - Exploit Fix Verification Tests
/// @notice Verifies that critical vulnerabilities from security audit are now fixed
/// @dev Run with: forge test --match-contract ExploitTests -vvvv
contract ExploitTests is Test {
  Permitter public target;

  address public owner = makeAddr("owner");
  address public trustedSigner;
  uint256 public signerPrivateKey;
  address public bidder = makeAddr("bidder");
  address public authorizedCaller = makeAddr("authorizedCaller");

  uint256 public constant INITIAL_MAX_TOTAL_ETH = 100 ether;
  uint256 public constant INITIAL_MAX_TOKENS_PER_BIDDER = 1000 ether;
  uint256 public constant INITIAL_MIN_TOKENS_PER_BIDDER = 10 ether;

  bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address bidder,uint256 expiry)");

  function setUp() public {
    signerPrivateKey = 0x1234;
    trustedSigner = vm.addr(signerPrivateKey);

    target = new Permitter(
      trustedSigner,
      INITIAL_MAX_TOTAL_ETH,
      INITIAL_MAX_TOKENS_PER_BIDDER,
      INITIAL_MIN_TOKENS_PER_BIDDER,
      owner,
      authorizedCaller
    );

    vm.label(address(target), "Permitter");
    vm.label(owner, "Owner");
    vm.label(bidder, "Bidder");
    vm.label(authorizedCaller, "AuthorizedCaller");
  }

  function _createPermitSignature(address _bidder, uint256 _expiry)
    internal
    view
    returns (bytes memory permitData)
  {
    IPermitter.Permit memory permit = IPermitter.Permit({bidder: _bidder, expiry: _expiry});

    bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, permit.bidder, permit.expiry));

    bytes32 domainSeparator = target.domainSeparator();
    bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
    bytes memory signature = abi.encodePacked(r, s, v);

    permitData = abi.encode(permit, signature);
  }

  /// ============================================================
  /// FIX VERIFICATION 1: Zero Caps Rejected in Constructor (C-01, H-03)
  /// ============================================================
  /// @notice Verify constructor rejects zero caps
  function test_ConstructorRejectsZeroCaps() public {
    console.log("\n=== FIX 1: Constructor Rejects Zero Caps ===");
    console.log("Fixes: C-01 (Critical), H-03 (High)");

    // Zero maxTotalEth should revert
    vm.expectRevert(IPermitter.InvalidCap.selector);
    new Permitter(
      trustedSigner,
      0, // maxTotalEth = 0 - REJECTED
      INITIAL_MAX_TOKENS_PER_BIDDER,
      INITIAL_MIN_TOKENS_PER_BIDDER,
      owner,
      authorizedCaller
    );
    console.log("Zero maxTotalEth correctly rejected");

    // Zero maxTokensPerBidder should revert
    vm.expectRevert(IPermitter.InvalidCap.selector);
    new Permitter(
      trustedSigner,
      INITIAL_MAX_TOTAL_ETH,
      0, // maxTokensPerBidder = 0 - REJECTED
      INITIAL_MIN_TOKENS_PER_BIDDER,
      owner,
      authorizedCaller
    );
    console.log("Zero maxTokensPerBidder correctly rejected");

    console.log("\nFIX VERIFIED: Constructor validates non-zero caps");
  }

  /// ============================================================
  /// FIX VERIFICATION 2: Zero Cap Updates Rejected (C-01)
  /// ============================================================
  /// @notice Verify cap update schedule rejects zero values
  function test_CapUpdateRejectsZeroCaps() public {
    console.log("\n=== FIX 2: Cap Updates Reject Zero Values ===");
    console.log("Fixes: C-01 (Critical)");

    vm.startPrank(owner);

    // Schedule zero maxTotalEth should revert
    vm.expectRevert(IPermitter.InvalidCap.selector);
    target.scheduleUpdateMaxTotalEth(0);
    console.log("Zero maxTotalEth update correctly rejected");

    // Schedule zero maxTokensPerBidder should revert
    vm.expectRevert(IPermitter.InvalidCap.selector);
    target.scheduleUpdateMaxTokensPerBidder(0);
    console.log("Zero maxTokensPerBidder update correctly rejected");

    vm.stopPrank();

    console.log("\nFIX VERIFIED: Zero cap updates prevented");
  }

  /// ============================================================
  /// FIX VERIFICATION 3: Timelock Prevents TOCTOU (H-01)
  /// ============================================================
  /// @notice Verify timelock prevents instant cap manipulation
  function test_TimelockPreventsTOCTOU() public {
    console.log("\n=== FIX 3: Timelock Prevents TOCTOU ===");
    console.log("Fixes: H-01 (High)");

    uint256 expiry = block.timestamp + 2 hours;
    bytes memory permitData = _createPermitSignature(bidder, expiry);

    // First bid succeeds
    vm.prank(authorizedCaller);
    target.validateBid(bidder, 200 ether, 20 ether, permitData);
    console.log("First bid succeeded. Bidder cumulative:", target.getBidAmount(bidder));

    // Owner schedules cap reduction
    console.log("\nOwner schedules maxTokensPerBidder reduction to 300 ether...");
    vm.prank(owner);
    target.scheduleUpdateMaxTokensPerBidder(300 ether);

    // Try to execute immediately - should fail due to timelock
    vm.prank(owner);
    vm.expectRevert();
    target.executeUpdateMaxTokensPerBidder();
    console.log("Immediate execution correctly blocked by timelock");

    // Second bid still succeeds because old cap is in effect
    vm.prank(authorizedCaller);
    target.validateBid(bidder, 250 ether, 25 ether, permitData);
    console.log("Second bid succeeded! New cumulative:", target.getBidAmount(bidder));

    console.log("\nFIX VERIFIED: 1-hour timelock prevents front-running");
  }

  /// ============================================================
  /// FIX VERIFICATION 4: State Invariant Protected (H-02)
  /// ============================================================
  /// @notice Verify cap cannot be reduced below current amount
  function test_StateInvariantProtected() public {
    console.log("\n=== FIX 4: State Invariant Protected ===");
    console.log("Fixes: H-02 (High)");

    uint256 expiry = block.timestamp + 2 hours;
    bytes memory permitData = _createPermitSignature(bidder, expiry);

    // Raise 50 ETH
    vm.prank(authorizedCaller);
    target.validateBid(bidder, 500 ether, 50 ether, permitData);
    console.log("ETH raised:", target.getTotalEthRaised());

    // Owner tries to schedule cap below already raised amount
    console.log("\nOwner schedules maxTotalEth reduction to 30 ether (below 50 raised)...");
    vm.prank(owner);
    target.scheduleUpdateMaxTotalEth(30 ether);

    // Advance past timelock
    vm.warp(block.timestamp + 1 hours + 1);

    // Execute should fail - cap would be below totalEthRaised
    vm.prank(owner);
    vm.expectRevert(
      abi.encodeWithSelector(
        IPermitter.CapBelowCurrentAmount.selector,
        30 ether, // proposed
        50 ether // current amount
      )
    );
    target.executeUpdateMaxTotalEth();
    console.log("Cap reduction below current amount correctly rejected");

    // Invariant still holds
    assertTrue(target.getTotalEthRaised() <= target.maxTotalEth(), "Invariant preserved");

    console.log("\nFIX VERIFIED: State invariant (totalEthRaised <= maxTotalEth) protected");
  }

  /// ============================================================
  /// FIX VERIFICATION 5: Caller Validation (M-01)
  /// ============================================================
  /// @notice Verify only authorized caller can call validateBid
  function test_CallerValidation() public {
    console.log("\n=== FIX 5: Caller Validation ===");
    console.log("Fixes: M-01 (Medium/High)");

    uint256 expiry = block.timestamp + 1 hours;
    bytes memory permitData = _createPermitSignature(bidder, expiry);

    address attacker = makeAddr("attacker");
    console.log("Attacker (not authorized):", attacker);

    // Attacker tries to directly call validateBid
    vm.prank(attacker);
    vm.expectRevert(IPermitter.UnauthorizedCaller.selector);
    target.validateBid(bidder, 100 ether, 10 ether, permitData);
    console.log("Attacker's call correctly rejected");

    // Authorized caller succeeds
    vm.prank(authorizedCaller);
    target.validateBid(bidder, 100 ether, 10 ether, permitData);
    console.log("Authorized caller succeeded");

    console.log("\nFIX VERIFIED: Only authorized caller can invoke validateBid");
  }

  /// ============================================================
  /// FIX VERIFICATION 6: Signer Rotation Timelock (M-02)
  /// ============================================================
  /// @notice Verify signer rotation has timelock for permit grace period
  function test_SignerRotationTimelock() public {
    console.log("\n=== FIX 6: Signer Rotation Timelock ===");
    console.log("Fixes: M-02 (Medium)");

    uint256 expiry = block.timestamp + 2 hours;
    bytes memory permitData = _createPermitSignature(bidder, expiry);

    console.log("Bidder has valid permit signed by:", trustedSigner);

    // Owner schedules new signer
    uint256 newSignerKey = 0x5678;
    address newSigner = vm.addr(newSignerKey);

    console.log("Owner schedules new signer:", newSigner);
    vm.prank(owner);
    target.scheduleUpdateTrustedSigner(newSigner);

    // Old permit still works during grace period
    vm.prank(authorizedCaller);
    target.validateBid(bidder, 100 ether, 10 ether, permitData);
    console.log("Old permit still valid during 1-hour grace period");

    console.log("\nFIX VERIFIED: Timelock provides grace period for permit users");
  }

  /// ============================================================
  /// REMAINING ISSUE: No Ownership Transfer (MEDIUM)
  /// ============================================================
  /// @notice Owner cannot be changed after deployment
  /// @dev This is still a limitation - consider adding Ownable2Step
  function test_NoOwnershipTransfer() public {
    console.log("\n=== REMAINING: No Ownership Transfer ===");
    console.log("Severity: Medium (not addressed in this fix)");

    address currentOwner = target.owner();
    console.log("Current owner:", currentOwner);

    // There is no transferOwnership function
    bytes4 transferSelector = bytes4(keccak256("transferOwnership(address)"));
    (bool success,) =
      address(target).staticcall(abi.encodeWithSelector(transferSelector, makeAddr("newOwner")));
    console.log("transferOwnership exists:", success);

    console.log("\nNOTE: Ownership transfer not implemented in current fix scope");
    console.log("Recommendation: Consider adding Ownable2Step in future");
  }

  /// ============================================================
  /// REMAINING ISSUE: Unbounded Pause (MEDIUM)
  /// ============================================================
  /// @notice Owner can pause indefinitely with no auto-unpause
  /// @dev This is still a limitation - consider adding max pause duration
  function test_UnboundedPause() public {
    console.log("\n=== REMAINING: Unbounded Pause ===");
    console.log("Severity: Medium (not addressed in this fix)");

    // Owner pauses
    vm.prank(owner);
    target.pause();
    console.log("Contract paused");

    // Fast forward 1 year
    vm.warp(block.timestamp + 365 days);

    // Still paused
    assertTrue(target.paused(), "Should still be paused");
    console.log("Contract still paused after 1 year");

    console.log("\nNOTE: Unbounded pause not addressed in current fix scope");
    console.log("Recommendation: Consider max pause duration or governance override");
  }
}
